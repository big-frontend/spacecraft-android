
import groovy.json.JsonSlurper
def child(Object msg) {
    println("ðŸ‘¶[ gradle initialzation ] " + msg);
}
/**
 * è¯»å–module_config.jsonä¿¡æ¯ä»¥æ­¤æ¥includeå…·ä½“çš„æ¨¡å—ï¼Œå¯¹äºŽæ¨¡å—çš„æè¿°åº”è¯¥æœ‰è¿™äº›ä¿¡æ¯
 * class Module{*    require  def simpleName æ¨¡å—åçš„ç®€å†™,ç»™idea pluginè¯»å–
 *    require def sourcePath :components:hotel-module:foundation
 *    require def format æ¨¡å—æ ¼å¼(bundle/bundle foundation/framework foundation/jar ,bundleå¯ä»¥ä¸å‚åŠ ç¼–è¯‘ï¼Œå³excludeï¼Œä½†æ˜¯framwork foundationå¿…é¡»è¢«include)
 *    require def group åˆ†ç»„æ˜¯ä¸ºäº†å½“excludeæŸä¸ªappæ—¶ï¼Œå…¶ä¸‹çš„ä¾èµ–çš„åŒç»„æ¨¡å—ä¹Ÿä¼šexclude
 *    option def deps
 *    ä¸åº”æœ‰è¿™ä¸ªå±žæ€§ï¼Œè¦ç¼–è¯‘æˆä»€ä¹ˆåº”è¯¥é€šè¿‡excludeModuleå’ŒsourceModule,é»˜è®¤éƒ½æ˜¯aarç¼–è¯‘//option def build_source(source or binary),binary(aar jar)ç¼–è¯‘æ›´å¿«
 *    require def binaryPath default: {package}:simpleName:1.0.0 ,é»˜è®¤çš„binary_artifactéœ€è¦ä¿è¯simpelNameå”¯ä¸€æ€§,å…ˆæš‚æ—¶ç”¨1.0.0ç«™ä½ï¼ŒåŽé¢åº”è¯¥é€šè¿‡èŽ·å–è¿œç¨‹ç‰ˆæœ¬å’Œæœ¬åœ°ç‰ˆæœ¬è¿›è¡Œè‡ªåŠ¨å‡çº§
 *}*
 */
def config = new JsonSlurper().parse(file("$rootDir/module_config.json"))
gradle.ext.allModules = config.allModules
def localProperties = new Properties()
def localPropertiesFile = new File(rootDir, 'local.properties')
if (localPropertiesFile.exists()) {
    localPropertiesFile.withReader('UTF-8') { reader ->
        localProperties.load(reader)
    }
}
def excludeModulesStr = localProperties.getProperty('excludeModules', '')
def sourceModulesStr = localProperties.getProperty('sourceModules', '')
def appsStr = localProperties.getProperty('apps', '')
gradle.ext.excludeModuleMap = new LinkedHashMap<String,Object>()
gradle.ext.sourceModuleMap = new LinkedHashMap<String,Object>()
gradle.ext.binaryModuleMap = new LinkedHashMap<String,Object>()
gradle.ext.framworkModuleMap = [:]
gradle.ext.bundleModuleMap = [:]
gradle.ext.appMap = [:]
def findModule = { name ->
    for (def m : gradle.ext.allModules) {
        if (m.simpleName == name) {
            return m
        }
    }
    return null
}
String.metaClass.eachAfterSplit { reg, Closure closure ->
    delegate.split(reg).each { name ->
        def m = findModule(name)
        if (m != null) {
            closure.call(m)
        }
    }
}
excludeModulesStr.eachAfterSplit(',') {
    gradle.ext.excludeModuleMap[it.simpleName] = it
}
sourceModulesStr.eachAfterSplit(',') {
    gradle.ext.sourceModuleMap[it.simpleName] = it
}
//appsStr.eachAfterSplit(',') { m ->
//    gradle.ext.appMap[m.simpleName] = m
//}
gradle.ext.allModules.each { m ->
    if (m.group == 'fwk'){
        gradle.ext.framworkModuleMap[m.simpleName] = m
    }
    if (!gradle.ext.sourceModuleMap.containsKey(m.simpleName) && !gradle.ext.excludeModuleMap.containsKey(m.simpleName)) {
        gradle.ext.binaryModuleMap[m.simpleName] = m
    }
}
child("module begin ========================================================================================")
//gradle.ext.appMap.each { _, module ->
//    child("app ${module.simpleName}")
//}
gradle.ext.sourceModuleMap.each { name, module ->
    child("source module\t${module.sourcePath}")
    if (module.simpleName == 'framework-flutter') {
        setBinding(new Binding([gradle: this]))
        evaluate(new File(settingsDir, 'script/flutter/include_flutter.gradle'))
    } else {
        include module.sourcePath
        if (module.projectDir) {
            project(module.sourcePath).projectDir = new File(rootProject.projectDir, module.projectDir)
        }
    }
}
gradle.ext.excludeModuleMap.each { _, module ->
    child("\u001B[31mexclude module\u001B[0m\t${module.sourcePath}")
}
gradle.ext.binaryModuleMap.each { _, module ->
    child("binary module\t${module.binaryPath}")
}

child("module end ========================================================================================")
//è¿™äº›åªèƒ½åœ¨settings.gradleä½¿ç”¨,æ˜¯å±žäºŽåˆå§‹åŒ–é˜¶æ®µçš„é’©å­
//gradle.settingsEvaluated {
//    println("settingsEvaluated")
//
//}
//gradle.projectsLoaded { g ->
//    println("projectsLoaded")
//}
